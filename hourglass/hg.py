import h5py;
import os;
import argparse;
import numpy as np;
import torch;
from tqdm import tqdm;
from hourglass.hg_files.test import inference;
from hourglass.hg_files import dp;
import utils.utils as ut;
import config as cf;

parts = {'mpii':['rank', 'rkne', 'rhip',
                 'lhip', 'lkne', 'lank',
                 'pelv', 'thrx', 'neck', 'head',
                 'rwri', 'relb', 'rsho',
                 'lsho', 'lelb', 'lwri']}

def load_model(hg_dir):
    """
    Loads the Hourglass model from the given directory.

    Parameters
    ----------
    hg_dir : str
        The full path to the hourglass directory.

    Returns
    -------
    model : tuple
        Returns two variables containing the model needed by the Hourglass 
        code
    """
    opt = argparse.Namespace(continue_exp='pose',exp='pose',max_iters=250);
    
    from hourglass.hg_files import pose as task;
    exp_path = 'exp\\pose';
    
    config = task.__config__
    try: os.makedirs(exp_path)
    except FileExistsError: pass
    
    config['opt'] = opt;
    config['data_provider'] = dp;
    
    func = task.make_network(config)
    
    reload(config,hg_dir);
    
    return (func, config);

def get_kp(frame,do,c,s):
    """
    Returns the keypoints for a single frame of video.

    Parameters
    ----------
    frame : numpy.ndarray
        The frame of video to be analysed.
    do : function
        Function provided by Hourglass code for inference.
    c : tuple of int
        The coordinates for the centre of the image.
    s : float
        The scale of the image such that height/scale = 200.

    Returns
    -------
    keypoints : numpy.ndarray
        The keypoints of the frame consisting of an x, y and confidence value 
        for each keypoint.
    """
    pred = do(frame,c,s);
    kps = pred[0]["keypoints"];
    return kps;

def get_kps(model, frame0, frame_gen, total):
    """
    Returns the keypoints for a sequcence of video frames.

    Parameters
    ----------
    model : tuple
        The model generated by the Hourglass code.
    frame0 : numpy.ndarray
        A sample frame from the video to ajust scale.
    frame_gen : generator
        A generator which provides the sequence of frames.
    total : int
        The total number of frames in the sequence.

    Returns
    -------
    keypoints : list of numpy.ndarray
        A list of keypoint values for each frame of the sequence.

    """
    c,s = ut.calc_cent_scale(frame0);
    
    do = get_do(model);
    kpss = [get_kp(frame0,do,c,s)]
    
    for frame in tqdm(frame_gen,initial=1,total=total):
        kpss.append(get_kp(frame,do,c,s));
        
    return kpss;

#Taken from test.py main()
def get_do(model):
    """
    Gets the do function for the hourglass code to perform inference.

    Parameters
    ----------
    model : tuple
        The model produced by the Hourglass code.

    Returns
    -------
    do : function
        The function needed for inference.

    """
    func = model[0];
    config = model[1];
    def runner(imgs):
        return func(0, config, 'inference', imgs=torch.Tensor(np.float32(imgs)))['preds']
    
    def do(img, c, s):
        ans = inference(img, runner, config, c, s)
        if len(ans) > 0:
            ans = ans[:,:,:3]
    
        ## ans has shape N,16,3 (num preds, joints, x/y/visible)
        pred = []
        for i in range(ans.shape[0]):
            pred.append({'keypoints': ans[i,:,:]})
        return pred
    return do;

def read_heatmap(fn):
    """
    Extracts a heatmap from the given file.

    Parameters
    ----------
    fn : str
        Path to file containing heatmap.

    Returns
    -------
    dataset : numpy.ndarray
        The extracted heatmap.

    """
    f = h5py.File(fn,'r');
    ds = f['heatmap'];
    ds = np.array(ds);
    f.close();
    ds = np.array(ds);
    #Equivilent to the reverse way ML reads data + the permute
    ds = np.transpose(ds,(1,2,0))
    return ds;

def convert_keypoints(kps,inSize,outSize):
    conkps = np.array(kps);
    
    scale = inSize / outSize;    
    for kp in conkps:
        kp[0] /= scale;
        kp[1] /= scale;
        
        kp[0] = min(kp[0],outSize - 1);
        kp[0] = max(0,kp[0]);
        
        kp[1] = min(kp[1],outSize - 1);
        kp[1] = max(0,kp[1]);
        
        kp[0] = int(kp[0]);
        kp[1] = int(kp[1]);
        
    return np.array([conkps]);

def gen_heatmaps(kpss,in_size,out_size):
    """
    Takes a set of keypoints and generates coresponding heatmaps.

    Parameters
    ----------
    kpss : numpy.ndarray
        Keypoints for each frame in the sequence in MPII format.
    in_size : int
        Size of the frame used to generate keypoints (n x n).
    out_size : int
        Size of the resulting heatmap (m x m).

    Returns
    -------
    hms : list of numpy.ndarray
        Heatmaps for each keypoint of each frame.
    """
    conKps = [convert_keypoints(kps,in_size,out_size) for kps in kpss];
    
    hmg = dp.GenerateHeatmap(out_size,16);
    
    hms = [hmg(kps) for kps in conKps];
    
    for i,hm in tqdm(enumerate(hms)):
        kps = kpss[i];
        for j,m in enumerate(hm):
            p = kps[j][2];
            #if j not in [9,10,11,12,13,14,15]: p = 0;
            m *= p;
            
    return hms;

def reload(config,hg_dir):
    """
    load or initialize model's parameters by config from config['opt'].continue_exp
    config['train']['epoch'] records the epoch num
    config['inference']['net'] is the model
    """
    opt = config['opt']

    if opt.continue_exp:
        resume = os.path.join(hg_dir + "\\exp", opt.continue_exp)
        resume_file = os.path.join(resume, 'checkpoint.pt')
        if os.path.isfile(resume_file):
            print("=> loading checkpoint '{}'".format(resume))
            checkpoint = torch.load(resume_file)

            config['inference']['net'].load_state_dict(checkpoint['state_dict'])
            config['train']['optimizer'].load_state_dict(checkpoint['optimizer'])
            config['train']['epoch'] = checkpoint['epoch']
            print("=> loaded checkpoint '{}' (epoch {})"
                  .format(resume, checkpoint['epoch']))
        else:
            print("=> no checkpoint found at '{}'".format(resume))

    if 'epoch' not in config['train']:
        config['train']['epoch'] = 0;
        
def get_get_kp(cap):
    model = load_model(cf.hg_dir);
    do = get_do(model);
    _,frame0 = cap.read();
    c,s = ut.calc_cent_scale(frame0);
    def gk(f):
        _,frame = cap.read();
        crop = ut.crop(frame,256,320);
        return get_kp(crop,do,c,s);
    return gk;